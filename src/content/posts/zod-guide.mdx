---
title: "Zod: Schema Validation from Basics to Advanced"
description: "A practical guide to Zod, covering primitives, objects, custom validation, transforms, and real-world patterns."
image: "../assets/blog/forms.jpg"
createdAt: 12-23-2024
draft: true
tags:
  - typescript
  - zod
---

Zod is a TypeScript-first schema validation library. You define the shape of your data once and get both runtime validation and static types.

---

## Why Zod?

TypeScript only checks types at compile time. Once your code runs, there's no guarantee that API responses, form inputs, or config files match what you expect.

Zod bridges that gap:

```typescript
import { z } from "zod";

const UserSchema = z.object({
  name: z.string(),
  email: z.string().email(),
  age: z.number().min(0),
});

// TypeScript type generated from schema
type User = z.infer<typeof UserSchema>;

// Runtime validation
const result = UserSchema.safeParse(unknownData);
if (result.success) {
  console.log(result.data); // fully typed User
} else {
  console.log(result.error.issues); // validation errors
}
```

One schema, two benefits: runtime safety and TypeScript types.

---

## Primitives

Zod covers all JavaScript primitives with built-in validators:

```typescript
// Strings
z.string()
z.string().min(1, "Required")
z.string().max(100)
z.string().email()
z.string().url()
z.string().uuid()
z.string().regex(/^[a-z]+$/)
z.string().startsWith("https://")
z.string().endsWith(".com")

// Numbers
z.number()
z.number().min(0)
z.number().max(100)
z.number().int()
z.number().positive()
z.number().negative()
z.number().multipleOf(5)

// Other primitives
z.boolean()
z.date()
z.bigint()
z.undefined()
z.null()
z.void()
z.any()
z.unknown()
```

Each method returns a new schema, so you can chain validators:

```typescript
const PasswordSchema = z
  .string()
  .min(8, "At least 8 characters")
  .regex(/[A-Z]/, "Must contain uppercase")
  .regex(/[0-9]/, "Must contain number");
```

---

## Objects

Most real-world data is structured. `z.object()` validates object shapes:

```typescript
const PersonSchema = z.object({
  name: z.string(),
  age: z.number(),
  email: z.string().email(),
});

type Person = z.infer<typeof PersonSchema>;
// { name: string; age: number; email: string }
```

### Nested objects

Objects can contain other objects:

```typescript
const CompanySchema = z.object({
  name: z.string(),
  address: z.object({
    street: z.string(),
    city: z.string(),
    country: z.string(),
  }),
});
```

### Extending and merging

You can build on existing schemas:

```typescript
const BaseUserSchema = z.object({
  id: z.string().uuid(),
  createdAt: z.date(),
});

const FullUserSchema = BaseUserSchema.extend({
  name: z.string(),
  email: z.string().email(),
});

// Or merge two schemas
const CombinedSchema = SchemaA.merge(SchemaB);
```

### Picking and omitting

Create subsets of existing schemas:

```typescript
const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string(),
  password: z.string(),
});

// Only id and name
const PublicUserSchema = UserSchema.pick({ id: true, name: true });

// Everything except password
const SafeUserSchema = UserSchema.omit({ password: true });
```

### Strict vs passthrough

By default, Zod strips unknown keys:

```typescript
const Schema = z.object({ name: z.string() });

Schema.parse({ name: "John", extra: "ignored" });
// { name: "John" } - extra is stripped

// To keep unknown keys:
Schema.passthrough().parse({ name: "John", extra: "kept" });
// { name: "John", extra: "kept" }

// To reject unknown keys:
Schema.strict().parse({ name: "John", extra: "error" });
// throws ZodError
```

---

## Arrays and Tuples

### Arrays

Validate arrays of a single type:

```typescript
const StringArraySchema = z.array(z.string());

// With constraints
const TagsSchema = z
  .array(z.string())
  .min(1, "At least one tag")
  .max(10, "Maximum 10 tags");

// Non-empty shorthand
const NonEmptySchema = z.array(z.string()).nonempty();
```

### Tuples

For fixed-length arrays with specific types:

```typescript
const CoordinatesSchema = z.tuple([z.number(), z.number()]);
// [number, number]

const MixedSchema = z.tuple([z.string(), z.number(), z.boolean()]);
// [string, number, boolean]
```

---

## Optional, Nullable, and Defaults

### Optional fields

```typescript
const Schema = z.object({
  name: z.string(),
  nickname: z.string().optional(), // string | undefined
});
```

### Nullable fields

```typescript
const Schema = z.object({
  name: z.string(),
  deletedAt: z.date().nullable(), // Date | null
});
```

### Both optional and nullable

```typescript
const Schema = z.object({
  value: z.string().nullish(), // string | null | undefined
});
```

### Default values

```typescript
const SettingsSchema = z.object({
  theme: z.enum(["light", "dark"]).default("light"),
  notifications: z.boolean().default(true),
  itemsPerPage: z.number().default(10),
});

SettingsSchema.parse({});
// { theme: "light", notifications: true, itemsPerPage: 10 }
```

---

## Enums and Literals

### Zod enums

```typescript
const StatusSchema = z.enum(["pending", "active", "completed"]);
type Status = z.infer<typeof StatusSchema>;
// "pending" | "active" | "completed"

// Access enum values
StatusSchema.enum.pending; // "pending"
StatusSchema.options; // ["pending", "active", "completed"]
```

### Native enums

If you already have a TypeScript enum:

```typescript
enum Role {
  Admin = "admin",
  User = "user",
  Guest = "guest",
}

const RoleSchema = z.nativeEnum(Role);
```

### Literals

For exact values:

```typescript
const VersionSchema = z.literal("v1");
const TrueSchema = z.literal(true);
const FortyTwoSchema = z.literal(42);
```

---

## Unions and Discriminated Unions

### Basic unions

When a value can be one of several types:

```typescript
const StringOrNumberSchema = z.union([z.string(), z.number()]);
// string | number

// Shorthand
const SameSchema = z.string().or(z.number());
```

### Discriminated unions

For objects that share a common field:

```typescript
const ResultSchema = z.discriminatedUnion("status", [
  z.object({ status: z.literal("success"), data: z.string() }),
  z.object({ status: z.literal("error"), message: z.string() }),
]);

type Result = z.infer<typeof ResultSchema>;
// { status: "success"; data: string } | { status: "error"; message: string }
```

Discriminated unions are more efficient because Zod can check the discriminator field first.

---

## Custom Validation with Refine

When built-in validators aren't enough, use `.refine()`:

```typescript
const PositiveEvenSchema = z
  .number()
  .refine((n) => n > 0, "Must be positive")
  .refine((n) => n % 2 === 0, "Must be even");
```

### Cross-field validation

Validate fields against each other:

```typescript
const PasswordFormSchema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"], // where to attach the error
  });
```

### Async validation

For validations that need API calls:

```typescript
const UsernameSchema = z
  .string()
  .min(3)
  .refine(async (username) => {
    const exists = await checkUsernameExists(username);
    return !exists;
  }, "Username already taken");

// Must use parseAsync
await UsernameSchema.parseAsync("newuser");
```

### SuperRefine for complex logic

When you need multiple errors or complex control flow:

```typescript
const FormSchema = z
  .object({
    type: z.enum(["personal", "business"]),
    companyName: z.string().optional(),
  })
  .superRefine((data, ctx) => {
    if (data.type === "business" && !data.companyName) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Company name required for business accounts",
        path: ["companyName"],
      });
    }
  });
```

---

## Transforms

Transform data during parsing:

```typescript
// Convert to lowercase
const EmailSchema = z.string().email().transform((s) => s.toLowerCase());

// Parse string to number
const NumberStringSchema = z.string().transform((s) => parseInt(s, 10));

// Parse and validate the result
const SafeNumberSchema = z
  .string()
  .transform((s) => parseInt(s, 10))
  .pipe(z.number().min(0));
```

### Preprocessing

Transform before validation:

```typescript
// Handle empty strings as undefined
const OptionalStringSchema = z.preprocess(
  (val) => (val === "" ? undefined : val),
  z.string().optional()
);

// Coerce types
const DateSchema = z.preprocess(
  (val) => (typeof val === "string" ? new Date(val) : val),
  z.date()
);
```

### Coercion shortcuts

Zod provides built-in coercion:

```typescript
z.coerce.string(); // String(value)
z.coerce.number(); // Number(value)
z.coerce.boolean(); // Boolean(value)
z.coerce.date(); // new Date(value)
```

---

## Error Handling

### Safe parsing

Use `safeParse` to handle errors without throwing:

```typescript
const result = UserSchema.safeParse(data);

if (result.success) {
  console.log(result.data);
} else {
  console.log(result.error.issues);
}
```

### Error structure

Each error issue contains:

```typescript
interface ZodIssue {
  code: string;
  message: string;
  path: (string | number)[]; // field path
  // ... additional fields based on error type
}
```

### Custom error messages

```typescript
const Schema = z.object({
  email: z.string({
    required_error: "Email is required",
    invalid_type_error: "Email must be a string",
  }).email({ message: "Invalid email format" }),
});
```

### Formatting errors

Transform errors for forms:

```typescript
const result = Schema.safeParse(formData);

if (!result.success) {
  const formatted = result.error.flatten();
  // {
  //   formErrors: string[],
  //   fieldErrors: { [field]: string[] }
  // }
}
```

---

## Real-World Patterns

### API response validation

```typescript
const ApiResponseSchema = z.object({
  data: z.array(UserSchema),
  pagination: z.object({
    page: z.number(),
    totalPages: z.number(),
    totalItems: z.number(),
  }),
});

async function fetchUsers() {
  const response = await fetch("/api/users");
  const json = await response.json();
  return ApiResponseSchema.parse(json);
}
```

### Environment variables

```typescript
const EnvSchema = z.object({
  DATABASE_URL: z.string().url(),
  API_KEY: z.string().min(1),
  PORT: z.coerce.number().default(3000),
  NODE_ENV: z.enum(["development", "production", "test"]),
});

export const env = EnvSchema.parse(process.env);
```

### Form schemas

```typescript
const RegistrationSchema = z
  .object({
    email: z.string().email(),
    password: z.string().min(8),
    confirmPassword: z.string(),
    terms: z.literal(true, {
      errorMap: () => ({ message: "You must accept the terms" }),
    }),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });
```

---

## Summary

Zod gives you:
- Runtime validation that matches your TypeScript types
- Composable schemas that build on each other
- Clear error messages for debugging
- Transforms for data normalization

Start with simple schemas and add complexity as needed. The type inference means your IDE stays helpful as your schemas grow.

